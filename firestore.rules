/**
 * @fileoverview Firestore Security Rules for GlamEase.
 *
 * Core Philosophy:
 * This ruleset enforces a user-ownership model for private data and allows public read access to service and promotion information.
 * It prioritizes security by strictly controlling write access based on user authentication and authorization.
 *
 * Data Structure:
 * - /users/{userId}: Stores user profile information. Only the user can read/write their own profile.
 * - /users/{userId}/clients/{clientId}: Stores client information. Only the user can manage their clients.
 * - /services/{serviceId}: Stores service information. Publicly readable.
 * - /promotions/{promotionId}: Stores promotion information. Publicly readable.
 * - /users/{userId}/appointments/{appointmentId}: Stores appointment information. Only the user can manage their appointments.
 *
 * Key Security Decisions:
 * - User listing is denied to prevent unauthorized access to user data.
 * - Public read access is granted for services and promotions to allow easy discovery.
 * - Data validation is minimal in the prototyping phase, focusing on authorization and relationship integrity.
 *
 * Denormalization for Authorization:
 * - User ownership is enforced through path-based rules (e.g., /users/{userId}/...).
 *   This avoids costly `get()` calls to verify ownership.
 *
 * Structural Segregation:
 * - Public data (services, promotions) is stored in top-level collections, while private data (clients, appointments) is stored under user-specific subcollections.
 *   This enables secure and efficient `list` operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description: Manages user profile data. Users can only read/write their own profile.
     * @path: /users/{userId}
     * @allow: User with UID 'user123' (create, update, get, delete)
     * @deny: User with UID 'otherUser' attempting to read/write 'user123' profile.
     * @principle: Enforces document ownership for all operations.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isOwner(userId);
      allow list: if false; // Listing all users is not permitted.
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description: Manages client data for a specific user. Only the authenticated user can access their own client data.
     * @path: /users/{userId}/clients/{clientId}
     * @allow: User with UID 'user123' creating/reading/writing client data under their 'user123' path.
     * @deny: User with UID 'otherUser' attempting to access client data under 'user123' path.
     * @principle: Enforces path-based ownership for all client data.
     */
    match /users/{userId}/clients/{clientId} {

      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }
      
      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description: Manages service data. All users can read service information, but creating, updating, or deleting services is not allowed in this prototype.
     * @path: /services/{serviceId}
     * @allow: Any user (get, list).
     * @deny: Any user (create, update, delete).
     * @principle: Public read access with restricted write access.
     */
    match /services/{serviceId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description: Manages promotion data. All users can read promotion information, but creating, updating, or deleting promotions is not allowed in this prototype.
     * @path: /promotions/{promotionId}
     * @allow: Any user (get, list).
     * @deny: Any user (create, update, delete).
     * @principle: Public read access with restricted write access.
     */
    match /promotions/{promotionId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description: Manages appointment data for a specific user. Only the authenticated user can access their own appointments.
     * @path: /users/{userId}/appointments/{appointmentId}
     * @allow: User with UID 'user123' creating/reading/writing appointment data under their 'user123' path.
     * @deny: User with UID 'otherUser' attempting to access appointment data under 'user123' path.
     * @principle: Enforces path-based ownership for all appointment data.
     */
    match /users/{userId}/appointments/{appointmentId} {

      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
      }

      allow get: if isSignedIn() && isOwner(userId);
      allow list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isSignedIn() && isExistingOwner(userId);
      allow delete: if isSignedIn() && isExistingOwner(userId);
    }
  }
}