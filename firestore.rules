/**
 * @fileoverview Firestore Security Rules for Thainnes Cuba Ciuldin application.
 *
 * Core Philosophy:
 * This ruleset prioritizes a secure, role-based access model, with clear ownership for user data and administrative control over configuration and content. It uses a combination of path-based and data-based authorization.
 *
 * Data Structure:
 * - /users/{userId}: User profiles, owned by the respective user.
 * - /services/{serviceId}: Publicly readable service information.
 * - /promotions/{promotionId}: Publicly readable promotion information.
 * - /appointments/{appointmentId}: Appointments, with client ownership enforced.
 * - /theme/{themeId}: Global theme settings, publicly readable, admin-writable.
 * - /socialMedia/{docId}: Social media links, publicly readable, admin-writable.
 * - /config/{docId}: Admin configuration (e.g., notification settings), admin-only.
 * - /galleryImages/{imageId}: Gallery image metadata, publicly readable, admin-writable.
 *
 * Key Security Decisions:
 * - Strict user ownership for /users/{userId} data.
 * - Public read access for /services, /promotions, /theme, /socialMedia, and /galleryImages.
 * - Admin-only access for /config.
 * - Client ownership for /appointments, with no client listing (admin listing only).
 *
 * Denormalization for Authorization:
 * - The /appointments collection contains a `clientId` field. This allows security rules to easily enforce ownership without needing to perform additional `get()` operations.
 *
 * Structural Segregation:
 * - Public data (services, promotions, theme, social media, gallery images) is stored in top-level collections, separate from private user data. This allows for performant and secure list operations.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows users to read and write their own user data.
     * @path /users/{userId}
     * @allow (get, update, delete) if request.auth.uid == userId
     * @allow (create) if request.auth.uid == request.resource.data.id
     * @allow (list) if request.auth.uid == userId
     * @deny (create) if request.auth.uid != request.resource.data.id
     * @deny (get, update, delete, list) if request.auth.uid != userId
     * @principle Enforces document ownership for writes.
     */
    match /users/{userId} {
      allow get, list: if isOwner(userId);
      allow create: if isOwner(userId) && request.auth.uid == request.resource.data.id;
      allow update: if isExistingOwner(userId) && request.auth.uid == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows anyone to read service data.
     * @path /services/{serviceId}
     * @allow (get, list) if true
     * @deny (create, update, delete) if true
     * @principle Public read access for service data.
     */
    match /services/{serviceId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows anyone to read promotion data.
     * @path /promotions/{promotionId}
     * @allow (get, list) if true
     * @deny (create, update, delete) if true
     * @principle Public read access for promotion data.
     */
    match /promotions/{promotionId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows clients to create appointments, and only the client can update/delete their appointment
     * @path /appointments/{appointmentId}
     * @allow (create) if isSignedIn()
     * @allow (get) if isSignedIn()
     * @allow (update, delete) if isExistingOwner(resource.data.clientId)
     * @deny (list) if true
     * @deny (create) if !isSignedIn()
     * @deny (update, delete) if !isExistingOwner(resource.data.clientId)
     * @principle Enforces client ownership for appointment management.
     */
    match /appointments/{appointmentId} {
        allow get: if isSignedIn();
        allow create: if isSignedIn();
        allow update: if isExistingOwner(resource.data.clientId);
        allow delete: if isExistingOwner(resource.data.clientId);
        allow list: if false;
    }

    /**
     * @description Allows anyone to read theme settings.
     * @path /theme/{themeId}
     * @allow (get, list) if true
     * @deny (create, update, delete) if true
     * @principle Public read access for theme settings.
     */
    match /theme/{themeId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows anyone to read social media links.
     * @path /socialMedia/{docId}
     * @allow (get, list) if true
     * @deny (create, update, delete) if true
     * @principle Public read access for social media links.
     */
    match /socialMedia/{docId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Only admins can read and write notification settings.
     * @path /config/{docId}
     * @deny (get, list, create, update, delete) if true
     * @principle Restricts access to notification settings to admins only.
     */
    match /config/{docId} {
      allow get, list, create, update, delete: if false;
    }

   /**
     * @description Allows anyone to read gallery image metadata.
     * @path /galleryImages/{imageId}
     * @allow (get, list) if true
     * @deny (create, update, delete) if true
     * @principle Public read access for gallery image metadata.
     */
    match /galleryImages/{imageId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
        return isOwner(userId) && resource != null;
    }
  }
}